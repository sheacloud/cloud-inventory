package codegen

import (
	"strings"
	"text/template"
)

var (
	structSourceCodeTemplateString = `type {{.Name}} struct {
{{range $index, $value := .Fields}}	{{$value.Name}} {{$value.Type}} {{$value.Tags}}
{{end}}}`
	structSourceCodeTemplate = template.Must(template.New("struct").Parse(structSourceCodeTemplateString))

	resourceFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package {{.ServiceName}}

{{if gt (len .RequiredImports) 0}}import (
{{range $index, $element := .RequiredImports}}	"{{$element}}"
{{end}}){{end}}

{{.ResourceStruct.MarshalToSourceCode}}
`
	resourceFileTemplate = template.Must(template.New("resourceFile").Parse(resourceFileTemplateString))

	referencedResourceFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package {{.ServiceName}}

{{if gt (len .RequiredImports) 0}}import (
{{range $index, $element := .RequiredImports}}	"{{$element}}"
{{end}}){{end}}

{{range $index, $element := .ReferencedStructs}}{{$element.MarshalToSourceCode}}
{{end}}
`
	referencedResourceFileTemplate = template.Must(template.New("referencedResourceFile").Parse(referencedResourceFileTemplateString))

	fetchingFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package {{.ServiceName}}

import (
	"context"
	"fmt"

	"github.com/aws/aws-sdk-go-v2/service/{{.ServiceName}}"
	"github.com/jinzhu/copier"
	"github.com/sheacloud/cloud-inventory/pkg/awscloud"
)

func Fetch{{.ResourceConfig.ObjectName}}(ctx context.Context, params *awscloud.AwsFetchInput) *awscloud.AwsFetchOutput {
	fetchingErrors := []error{}
	var fetchedResources int
	var failedResources int

	awsClient := params.RegionalClients[params.Region]
	client := awsClient.{{.SdkClientName}}()

	{{if .ResourceConfig.Pagination}}
	paginator := {{.ServiceName}}.New{{.ResourceConfig.FetchFunction}}Paginator(client, &{{.ServiceName}}.{{.ResourceConfig.FetchFunction}}Input{})

	for paginator.HasMorePages() {
		output, err := paginator.NextPage(ctx)
	{{else}}

	result, err := client.{{.ResourceConfig.FetchFunction}}(ctx, &{{.ServiceName}}.{{.ResourceConfig.FetchFunction}}Input{})
	if err != nil {
		fetchingErrors = append(fetchingErrors, fmt.Errorf("error calling {{.ResourceConfig.FetchFunction}} in %s/%s: %w", params.AccountId, params.Region, err))
		return &awscloud.AwsFetchOutput{
			FetchingErrors:   fetchingErrors,
			FetchedResources: fetchedResources,
			FailedResources:  failedResources,
			ResourceName:     "{{.ResourceConfig.Name}}",
			AccountId:        params.AccountId,
			Region:           params.Region,
		}
	}

	results := []*{{.ServiceName}}.{{.ResourceConfig.FetchFunction}}Output{result}
	for _, output := range results {
	{{end}}
		if err != nil {
			fetchingErrors = append(fetchingErrors, fmt.Errorf("error calling {{.ResourceConfig.FetchFunction}} in %s/%s: %w", params.AccountId, params.Region, err))
			break
		}

		for _, object := range output.{{.ResourceConfig.ObjectResponseField}} {

			model := new({{.ResourceConfig.ObjectName}})
			copier.Copy(&model, &object)

			{{if .ShouldConvertTags}}model.Tags = ConvertTags(object.{{.TagListFieldName}}){{end}}
			model.AccountId = params.AccountId
			model.Region = params.Region
			model.ReportTime = params.ReportTime.UTC().UnixMilli()

			{{if .ResourceConfig.UsePostProcessing}}
			if err = PostProcess{{.ResourceConfig.ObjectName}}(ctx, params, model); err != nil {
				fetchingErrors = append(fetchingErrors, fmt.Errorf("error post-processing {{.ResourceConfig.ObjectName}} %s %s/%s: %w", model.{{.ResourceConfig.ObjectUniqueId}}, params.AccountId, params.Region, err))
				failedResources++
			}
			{{end}}

			err = params.OutputFile.Write(ctx, model)
			if err != nil {
				fetchingErrors = append(fetchingErrors, fmt.Errorf("error storing {{.ResourceConfig.ObjectName}} model in %s/%s: %w", params.AccountId, params.Region, err))
			}
			fetchedResources++
		}

	}

	return &awscloud.AwsFetchOutput{
		FetchingErrors:   fetchingErrors,
		FetchedResources: fetchedResources,
		FailedResources:  failedResources,
		ResourceName:     "{{.ResourceConfig.Name}}",
		AccountId:        params.AccountId,
		Region:           params.Region,
	}
}
`
	fetchingFileTemplate = template.Must(template.New("fetchingFile").Parse(fetchingFileTemplateString))

	serviceClientInterfaceFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package interfaces

import (
	"context"

	"{{.SdkPath}}"
)

type {{.SdkClientName}}Client interface {
{{range $index, $element := .UtilizedFunctions}}	{{$element}}(ctx context.Context, params *{{$.ServiceName}}.{{$element}}Input, optFns ...func(*{{$.ServiceName}}.Options)) (*{{$.ServiceName}}.{{$element}}Output, error)
{{end}}}
`
	serviceClientInterfaceFileTemplate = template.Must(template.New("serviceClientInterfaceFile").Parse(serviceClientInterfaceFileTemplateString))

	clientInterfaceFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package interfaces

type AwsClient interface {
{{range $index, $element := .Services}}	{{$element.ServiceCapName}}() {{$element.ServiceCapName}}Client
{{end}}}
`
	clientInterfaceFileTemplate = template.Must(template.New("clientInterfaceFile").Parse(clientInterfaceFileTemplateString))

	clientFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package awscloud

import (
	"github.com/aws/aws-sdk-go-v2/aws"
{{range $index, $element := .Services}}	"{{$element.SdkPath}}"
{{end}}
	"github.com/sheacloud/cloud-inventory/pkg/awscloud/interfaces"
)

type AwsClient struct {
{{range $index, $element := .Services}}	{{$element.Name}}Client *{{$element.Name}}.Client
{{end}}}

func NewAwsClient(cfg aws.Config) *AwsClient {
	return &AwsClient{
{{range $index, $element := .Services}}		{{$element.Name}}Client: {{$element.Name}}.NewFromConfig(cfg),
{{end}}	}
}

{{range $index, $element := .Services}}func (c *AwsClient) {{$element.ServiceCapName}}() interfaces.{{$element.ServiceCapName}}Client {
	return c.{{$element.Name}}Client
}
{{end}}
`
	clientFileTemplate = template.Must(template.New("clientFile").Parse(clientFileTemplateString))

	catalogFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package inventory

import (
	"context"

	"github.com/sheacloud/cloud-inventory/pkg/awscloud"
{{range $index, $element := .Services}}	"github.com/sheacloud/cloud-inventory/pkg/awscloud/services/{{$element.Name}}"
{{end}})

type AwsCatalogResource struct {
	ResourceName  string
	ResourceModel interface{}
	FetchFunction func(context.Context, *awscloud.AwsFetchInput) *awscloud.AwsFetchOutput
}

type AwsCatalogService struct {
	ServiceName     string
	RegionOverrides []string
	Resources       []AwsCatalogResource
}

var (
	AwsCatalog = []AwsCatalogService{
{{range $serviceIndex, $serviceElement := .Services}}		{
			ServiceName: "{{$serviceElement.Name}}",
			RegionOverrides: []string{{"{"}}{{if $serviceElement.HasRegionOverride}}"{{$serviceElement.RegionOverride}}"{{else}}{{end}}{{"},"}}
			Resources: []AwsCatalogResource{
{{range $resourceIndex, $resourceElement := $serviceElement.Resources}}				{
					ResourceName: "{{$resourceElement.Name}}",
					ResourceModel: &{{$serviceElement.Name}}.{{$resourceElement.ObjectName}}{},
					FetchFunction: {{$serviceElement.Name}}.Fetch{{$resourceElement.ObjectName}},
				},
{{end}}
			},
		},
{{end}}
	}
)
`
	catalogFileTemplate = template.Must(template.New("catalogFile").Parse(catalogFileTemplateString))

	helpersFileTemplateString = `//AUTOGENERATED CODE DO NOT EDIT
package {{.ServiceName}}

import (
	"github.com/aws/aws-sdk-go-v2/service/{{.ServiceName}}/types"
)

func ConvertTags(tags []types.{{.TagObjectName}}) map[string]string {
	tagMap := make(map[string]string)
	for _, tag := range tags {
		tagMap[*tag.Key] = *tag.Value
	}
	return tagMap
}
`
	helpersFileTemplate = template.Must(template.New("helpersFile").Parse(helpersFileTemplateString))
)

type AwsTemplate struct {
	Services []*AwsServiceConfig `hcl:"aws_service,block"`
}

func (t *AwsTemplate) GetClientInterfaceFileCode() string {
	var buf strings.Builder
	err := clientInterfaceFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (t *AwsTemplate) GetClientFileCode() string {
	var buf strings.Builder
	err := clientFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (t *AwsTemplate) GetCatalogFileCode() string {
	var buf strings.Builder
	err := catalogFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

type AwsServiceTemplate struct {
	ServiceName       string
	TagObjectName     string
	SdkPath           string
	SdkClientName     string
	UtilizedFunctions []string
}

func (t *AwsServiceTemplate) GetServiceClientInterfaceFileCode() string {
	var buf strings.Builder
	err := serviceClientInterfaceFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (t *AwsServiceTemplate) GetHelpersFileCode() string {
	var buf strings.Builder
	err := helpersFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

type AwsResourceTemplate struct {
	ServiceName       string
	ResourceStruct    *StructModel
	ResourceConfig    *AwsResourceConfig
	RequiredImports   []string
	SdkClientName     string
	ShouldConvertTags bool
	TagListFieldName  string
}

func (t *AwsResourceTemplate) DetermineRequiredImports() {
	t.RequiredImports = t.ResourceStruct.GetRequiredImports()
	t.RequiredImports = Deduplicate(t.RequiredImports)
}

func (t *AwsResourceTemplate) GetResourceFileCode() string {
	var buf strings.Builder
	err := resourceFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

func (t *AwsResourceTemplate) GetFetchingFileCode() string {
	var buf strings.Builder
	err := fetchingFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

type AwsReferencedResourceTemplate struct {
	ServiceName       string
	ReferencedStructs []*StructModel
	RequiredImports   []string
}

func (t *AwsReferencedResourceTemplate) DetermineRequiredImports() {
	t.RequiredImports = []string{}
	for _, structModel := range t.ReferencedStructs {
		t.RequiredImports = append(t.RequiredImports, structModel.GetRequiredImports()...)
	}
	t.RequiredImports = Deduplicate(t.RequiredImports)
}

func (t *AwsReferencedResourceTemplate) GetReferencedResourceFileCode() string {
	var buf strings.Builder
	err := referencedResourceFileTemplate.Execute(&buf, t)
	if err != nil {
		panic(err)
	}
	return buf.String()
}
