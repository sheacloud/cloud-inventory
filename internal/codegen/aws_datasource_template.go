package codegen

import (
	"strings"
	"text/template"
)

var (
	funcMap template.FuncMap = template.FuncMap{
		// The name "inc" is what the function will be called in the template text.
		"sub": func(i, j int) int {
			return i - j
		},
		"tab": func(i int) string {
			result := ""
			for k := 0; k < i; k++ {
				result += "	"
			}
			return result
		},
		"len": func(s []string) int {
			return len(s)
		},
	}

	awsDataSourceFileTemplateString = `// AUTOGENERATED, DO NOT EDIT
package {{.ServiceName}}
import (
	{{if not .ModelsOnly}}
	"fmt"
	"github.com/jinzhu/copier"
	"github.com/sirupsen/logrus"
	"github.com/sheacloud/cloud-inventory/internal/storage"
	"time"
	{{end}}
	"context"
	"sync"
	"github.com/aws/aws-sdk-go-v2/service/{{.ServiceName}}"
	"github.com/aws/aws-sdk-go-v2/aws"
)

var custom{{.PrimaryModel.Name}}PostprocessingFuncs []func(ctx context.Context, client *{{.ServiceName}}.Client, cfg aws.Config, x *{{.PrimaryModel.Name}}) = []func(ctx context.Context, client *{{.ServiceName}}.Client, cfg aws.Config, x *{{.PrimaryModel.Name}}){}
var custom{{.PrimaryModel.Name}}FuncsLock sync.Mutex

func registerCustom{{.PrimaryModel.Name}}PostprocessingFunc(f func(ctx context.Context, client *{{.ServiceName}}.Client, cfg aws.Config, x *{{.PrimaryModel.Name}})) {
	custom{{.PrimaryModel.Name}}FuncsLock.Lock()
	defer custom{{.PrimaryModel.Name}}FuncsLock.Unlock()

	custom{{.PrimaryModel.Name}}PostprocessingFuncs = append(custom{{.PrimaryModel.Name}}PostprocessingFuncs, f)
}

func init() {
	Controller.RegisterDataSource("{{.DataSourceName}}", {{.PrimaryObjectName}}DataSource)
}

{{range $index, $element := .Models}}
{{$element.StructSourceCode}}
{{end}}
{{$pathLength := len .PrimaryObjectPath}}

{{if not .ModelsOnly}}
func {{.PrimaryObjectName}}DataSource(ctx context.Context, client *{{.ServiceName}}.Client, cfg aws.Config, reportTime time.Time, storageConfig storage.StorageContextConfig, storageManager *storage.StorageManager) error {
	storageContextSet, err := storageManager.GetStorageContextSet(storageConfig, new({{.PrimaryObjectName}}Model))
	if err != nil {
		return err
	}
	defer storageContextSet.Close(ctx)

	{{if .Paginate}}
	paginator := {{.ServiceName}}.New{{.ApiFunction}}Paginator(client, &{{.ServiceName}}.{{.ApiFunction}}Input{})

	for paginator.HasMorePages() {
		output, err := paginator.NextPage(ctx)
		if err != nil {
			logrus.WithFields(logrus.Fields{
				"service":     storageConfig.Service,
				"data_source": storageConfig.DataSource,
				"account_id":  storageConfig.AccountId,
				"region":      storageConfig.Region,
				"cloud":       storageConfig.Cloud,
				"error":       err,
			}).Error("error calling {{.ApiFunction}}")
			return err
		}
	{{else}}
	params := &{{.ServiceName}}.{{.ApiFunction}}Input{}
	
	result, err := client.{{.ApiFunction}}(ctx, params)
	if err != nil {
		logrus.WithFields(logrus.Fields{
			"service":     storageConfig.Service,
			"data_source": storageConfig.DataSource,
			"account_id":  storageConfig.AccountId,
			"region":      storageConfig.Region,
			"cloud":       storageConfig.Cloud,
			"error":       err,
		}).Error("error calling {{.ApiFunction}}")
		return err
	}

	results := []*{{.ServiceName}}.{{.ApiFunction}}Output{result}
	for _, output := range results {
	{{end}}
		{{range $index, $element := .PrimaryObjectPath}}{{tab $index}}for _, var{{$index}} := range {{if eq $index 0}}output{{else}}var{{sub $index 1}}{{end}}.{{$element}} {
		{{end}}
		{{tab $pathLength}}model := new({{.PrimaryObjectName}}Model)
		{{tab $pathLength}}copier.Copy(&model, &var{{sub $pathLength 1}})

		{{range $index, $element := .PrimaryModel.FieldConversions}}{{tab $pathLength}}model.{{$element.TargetField.Name}} = {{$element.ConversionFunctionName}}(var{{sub $pathLength 1}}.{{$element.SourceFieldName}}){{end}}
		{{tab $pathLength}}model.AccountId = storageConfig.AccountId
		{{tab $pathLength}}model.Region = storageConfig.Region
		{{tab $pathLength}}model.ReportTime = reportTime.UTC().UnixMilli()

		{{tab $pathLength}}for _, f := range custom{{.PrimaryModel.Name}}PostprocessingFuncs {
		{{tab $pathLength}}	f(ctx, client, cfg, model)
		{{tab $pathLength}}}

		{{tab $pathLength}}errors := storageContextSet.Store(ctx, model)
		{{tab $pathLength}}for storageContext, err := range errors {
		{{tab $pathLength}}	storage.LogContextError(storageContext, fmt.Sprintf("Error storing {{.PrimaryObjectName}}Model: %v", err))
		{{tab $pathLength}}}
		{{range $index, $element := .PrimaryObjectPath}}{{tab (sub (sub $pathLength 1) $index)}}}
		{{end}}
	}

	return nil
}
{{end}}
`
	awsDataSourceFileTemplate = template.Must(template.New("file").Funcs(funcMap).Parse(awsDataSourceFileTemplateString))
)

type AwsDataSourceFile struct {
	ServiceName       string
	DataSourceName    string
	PrimaryObjectName string
	ApiFunction       string
	Models            []*ParquetModelStruct
	PrimaryObjectPath []string
	PrimaryModel      *ParquetModelStruct
	Paginate          bool
	ModelsOnly        bool
}

func (d *AwsDataSourceFile) SourceCode() string {
	var buf strings.Builder
	err := awsDataSourceFileTemplate.Execute(&buf, d)
	if err != nil {
		panic(err)
	}
	return buf.String()
}
