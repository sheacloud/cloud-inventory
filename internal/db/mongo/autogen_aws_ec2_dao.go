//AUTOGENERATED CODE DO NOT EDIT
package mongo

import (
	"context"
	"github.com/sheacloud/cloud-inventory/internal/db"
	"github.com/sheacloud/cloud-inventory/pkg/aws/ec2"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"time"
)

type MongoEC2DAO struct {
	db *mongo.Database
}

func (dao *MongoEC2DAO) ListAddresses(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Address, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.Address
	cursor, err := dao.db.Collection("aws_ec2_addresses").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetAddress(ctx context.Context, reportTime time.Time, id string) (*ec2.Address, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"allocation_id", id},
	}

	var result *ec2.Address
	err := dao.db.Collection("aws_ec2_addresses").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutAddresses(ctx context.Context, resources []*ec2.Address) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.addresses").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetAddressReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_addresses"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedAddressReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_addresses"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListDhcpOptions(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.DhcpOptions, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.DhcpOptions
	cursor, err := dao.db.Collection("aws_ec2_dhcp_options").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetDhcpOptions(ctx context.Context, reportTime time.Time, id string) (*ec2.DhcpOptions, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"dhcp_options_id", id},
	}

	var result *ec2.DhcpOptions
	err := dao.db.Collection("aws_ec2_dhcp_options").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutDhcpOptions(ctx context.Context, resources []*ec2.DhcpOptions) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.dhcp_options").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetDhcpOptionsReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_dhcp_options"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedDhcpOptionsReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_dhcp_options"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListImages(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Image, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.Image
	cursor, err := dao.db.Collection("aws_ec2_images").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetImage(ctx context.Context, reportTime time.Time, id string) (*ec2.Image, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"image_id", id},
	}

	var result *ec2.Image
	err := dao.db.Collection("aws_ec2_images").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutImages(ctx context.Context, resources []*ec2.Image) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.images").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetImageReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_images"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedImageReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_images"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListInstances(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Instance, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.Instance
	cursor, err := dao.db.Collection("aws_ec2_instances").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetInstance(ctx context.Context, reportTime time.Time, id string) (*ec2.Instance, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"instance_id", id},
	}

	var result *ec2.Instance
	err := dao.db.Collection("aws_ec2_instances").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutInstances(ctx context.Context, resources []*ec2.Instance) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.instances").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetInstanceReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_instances"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedInstanceReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_instances"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListInternetGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.InternetGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.InternetGateway
	cursor, err := dao.db.Collection("aws_ec2_internet_gateways").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetInternetGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.InternetGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"internet_gateway_id", id},
	}

	var result *ec2.InternetGateway
	err := dao.db.Collection("aws_ec2_internet_gateways").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutInternetGateways(ctx context.Context, resources []*ec2.InternetGateway) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.internet_gateways").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetInternetGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_internet_gateways"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedInternetGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_internet_gateways"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListManagedPrefixLists(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.ManagedPrefixList, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.ManagedPrefixList
	cursor, err := dao.db.Collection("aws_ec2_managed_prefix_lists").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetManagedPrefixList(ctx context.Context, reportTime time.Time, id string) (*ec2.ManagedPrefixList, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"prefix_list_arn", id},
	}

	var result *ec2.ManagedPrefixList
	err := dao.db.Collection("aws_ec2_managed_prefix_lists").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutManagedPrefixLists(ctx context.Context, resources []*ec2.ManagedPrefixList) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.managed_prefix_lists").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetManagedPrefixListReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_managed_prefix_lists"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedManagedPrefixListReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_managed_prefix_lists"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListNatGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.NatGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.NatGateway
	cursor, err := dao.db.Collection("aws_ec2_nat_gateways").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetNatGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.NatGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"nat_gateway_id", id},
	}

	var result *ec2.NatGateway
	err := dao.db.Collection("aws_ec2_nat_gateways").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutNatGateways(ctx context.Context, resources []*ec2.NatGateway) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.nat_gateways").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetNatGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_nat_gateways"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedNatGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_nat_gateways"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListNetworkAcls(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.NetworkAcl, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.NetworkAcl
	cursor, err := dao.db.Collection("aws_ec2_network_acls").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetNetworkAcl(ctx context.Context, reportTime time.Time, id string) (*ec2.NetworkAcl, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"network_acl_id", id},
	}

	var result *ec2.NetworkAcl
	err := dao.db.Collection("aws_ec2_network_acls").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutNetworkAcls(ctx context.Context, resources []*ec2.NetworkAcl) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.network_acls").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetNetworkAclReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_network_acls"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedNetworkAclReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_network_acls"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListNetworkInterfaces(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.NetworkInterface, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.NetworkInterface
	cursor, err := dao.db.Collection("aws_ec2_network_interfaces").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetNetworkInterface(ctx context.Context, reportTime time.Time, id string) (*ec2.NetworkInterface, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"network_interface_id", id},
	}

	var result *ec2.NetworkInterface
	err := dao.db.Collection("aws_ec2_network_interfaces").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutNetworkInterfaces(ctx context.Context, resources []*ec2.NetworkInterface) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.network_interfaces").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetNetworkInterfaceReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_network_interfaces"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedNetworkInterfaceReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_network_interfaces"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListPlacementGroups(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.PlacementGroup, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.PlacementGroup
	cursor, err := dao.db.Collection("aws_ec2_placement_groups").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetPlacementGroup(ctx context.Context, reportTime time.Time, id string) (*ec2.PlacementGroup, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"group_id", id},
	}

	var result *ec2.PlacementGroup
	err := dao.db.Collection("aws_ec2_placement_groups").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutPlacementGroups(ctx context.Context, resources []*ec2.PlacementGroup) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.placement_groups").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetPlacementGroupReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_placement_groups"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedPlacementGroupReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_placement_groups"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListReservedInstances(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.ReservedInstances, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.ReservedInstances
	cursor, err := dao.db.Collection("aws_ec2_reserved_instances").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetReservedInstances(ctx context.Context, reportTime time.Time, id string) (*ec2.ReservedInstances, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"reserved_instances_id", id},
	}

	var result *ec2.ReservedInstances
	err := dao.db.Collection("aws_ec2_reserved_instances").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutReservedInstances(ctx context.Context, resources []*ec2.ReservedInstances) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.reserved_instances").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetReservedInstancesReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_reserved_instances"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedReservedInstancesReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_reserved_instances"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListRouteTables(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.RouteTable, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.RouteTable
	cursor, err := dao.db.Collection("aws_ec2_route_tables").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetRouteTable(ctx context.Context, reportTime time.Time, id string) (*ec2.RouteTable, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"route_table_id", id},
	}

	var result *ec2.RouteTable
	err := dao.db.Collection("aws_ec2_route_tables").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutRouteTables(ctx context.Context, resources []*ec2.RouteTable) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.route_tables").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetRouteTableReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_route_tables"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedRouteTableReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_route_tables"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListSecurityGroups(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.SecurityGroup, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.SecurityGroup
	cursor, err := dao.db.Collection("aws_ec2_security_groups").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetSecurityGroup(ctx context.Context, reportTime time.Time, id string) (*ec2.SecurityGroup, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"group_id", id},
	}

	var result *ec2.SecurityGroup
	err := dao.db.Collection("aws_ec2_security_groups").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutSecurityGroups(ctx context.Context, resources []*ec2.SecurityGroup) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.security_groups").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetSecurityGroupReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_security_groups"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedSecurityGroupReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_security_groups"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListSubnets(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Subnet, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.Subnet
	cursor, err := dao.db.Collection("aws_ec2_subnets").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetSubnet(ctx context.Context, reportTime time.Time, id string) (*ec2.Subnet, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"subnet_id", id},
	}

	var result *ec2.Subnet
	err := dao.db.Collection("aws_ec2_subnets").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutSubnets(ctx context.Context, resources []*ec2.Subnet) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.subnets").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetSubnetReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_subnets"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedSubnetReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_subnets"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListTransitGatewayPeeringAttachments(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGatewayPeeringAttachment, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.TransitGatewayPeeringAttachment
	cursor, err := dao.db.Collection("aws_ec2_transit_gateway_peering_attachments").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetTransitGatewayPeeringAttachment(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGatewayPeeringAttachment, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"transit_gateway_attachment_id", id},
	}

	var result *ec2.TransitGatewayPeeringAttachment
	err := dao.db.Collection("aws_ec2_transit_gateway_peering_attachments").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutTransitGatewayPeeringAttachments(ctx context.Context, resources []*ec2.TransitGatewayPeeringAttachment) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.transit_gateway_peering_attachments").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetTransitGatewayPeeringAttachmentReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_transit_gateway_peering_attachments"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedTransitGatewayPeeringAttachmentReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_transit_gateway_peering_attachments"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListTransitGatewayRouteTables(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGatewayRouteTable, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.TransitGatewayRouteTable
	cursor, err := dao.db.Collection("aws_ec2_transit_gateway_route_tables").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetTransitGatewayRouteTable(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGatewayRouteTable, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"transit_gateway_route_table_id", id},
	}

	var result *ec2.TransitGatewayRouteTable
	err := dao.db.Collection("aws_ec2_transit_gateway_route_tables").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutTransitGatewayRouteTables(ctx context.Context, resources []*ec2.TransitGatewayRouteTable) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.transit_gateway_route_tables").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetTransitGatewayRouteTableReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_transit_gateway_route_tables"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedTransitGatewayRouteTableReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_transit_gateway_route_tables"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListTransitGatewayVpcAttachments(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGatewayVpcAttachment, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.TransitGatewayVpcAttachment
	cursor, err := dao.db.Collection("aws_ec2_transit_gateway_vpc_attachments").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetTransitGatewayVpcAttachment(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGatewayVpcAttachment, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"transit_gateway_attachment_id", id},
	}

	var result *ec2.TransitGatewayVpcAttachment
	err := dao.db.Collection("aws_ec2_transit_gateway_vpc_attachments").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutTransitGatewayVpcAttachments(ctx context.Context, resources []*ec2.TransitGatewayVpcAttachment) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.transit_gateway_vpc_attachments").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetTransitGatewayVpcAttachmentReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_transit_gateway_vpc_attachments"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedTransitGatewayVpcAttachmentReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_transit_gateway_vpc_attachments"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListTransitGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.TransitGateway
	cursor, err := dao.db.Collection("aws_ec2_transit_gateways").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetTransitGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"transit_gateway_id", id},
	}

	var result *ec2.TransitGateway
	err := dao.db.Collection("aws_ec2_transit_gateways").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutTransitGateways(ctx context.Context, resources []*ec2.TransitGateway) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.transit_gateways").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetTransitGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_transit_gateways"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedTransitGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_transit_gateways"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListVolumes(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Volume, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.Volume
	cursor, err := dao.db.Collection("aws_ec2_volumes").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetVolume(ctx context.Context, reportTime time.Time, id string) (*ec2.Volume, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"volume_id", id},
	}

	var result *ec2.Volume
	err := dao.db.Collection("aws_ec2_volumes").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutVolumes(ctx context.Context, resources []*ec2.Volume) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.volumes").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetVolumeReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_volumes"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedVolumeReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_volumes"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListVpcEndpoints(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.VpcEndpoint, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.VpcEndpoint
	cursor, err := dao.db.Collection("aws_ec2_vpc_endpoints").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetVpcEndpoint(ctx context.Context, reportTime time.Time, id string) (*ec2.VpcEndpoint, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"vpc_endpoint_id", id},
	}

	var result *ec2.VpcEndpoint
	err := dao.db.Collection("aws_ec2_vpc_endpoints").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutVpcEndpoints(ctx context.Context, resources []*ec2.VpcEndpoint) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.vpc_endpoints").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetVpcEndpointReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_vpc_endpoints"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedVpcEndpointReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_vpc_endpoints"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListVpcPeeringConnections(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.VpcPeeringConnection, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.VpcPeeringConnection
	cursor, err := dao.db.Collection("aws_ec2_vpc_peering_connections").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetVpcPeeringConnection(ctx context.Context, reportTime time.Time, id string) (*ec2.VpcPeeringConnection, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"vpc_peering_connection_id", id},
	}

	var result *ec2.VpcPeeringConnection
	err := dao.db.Collection("aws_ec2_vpc_peering_connections").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutVpcPeeringConnections(ctx context.Context, resources []*ec2.VpcPeeringConnection) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.vpc_peering_connections").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetVpcPeeringConnectionReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_vpc_peering_connections"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedVpcPeeringConnectionReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_vpc_peering_connections"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListVpcs(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Vpc, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.Vpc
	cursor, err := dao.db.Collection("aws_ec2_vpcs").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetVpc(ctx context.Context, reportTime time.Time, id string) (*ec2.Vpc, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"vpc_id", id},
	}

	var result *ec2.Vpc
	err := dao.db.Collection("aws_ec2_vpcs").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutVpcs(ctx context.Context, resources []*ec2.Vpc) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.vpcs").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetVpcReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_vpcs"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedVpcReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_vpcs"), reportDate, timeSelection, timeReference)
}

func (dao *MongoEC2DAO) ListVpnGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.VpnGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
	}
	if accountID != nil {
		filter = append(filter, bson.E{Key: "account_id", Value: *accountID})
	}
	if region != nil {
		filter = append(filter, bson.E{Key: "region", Value: *region})
	}

	var results []*ec2.VpnGateway
	cursor, err := dao.db.Collection("aws_ec2_vpn_gateways").Find(ctx, filter)
	if err != nil {
		return nil, err
	}

	err = cursor.All(ctx, &results)
	if err != nil {
		return nil, err
	}

	return results, nil
}

func (dao *MongoEC2DAO) GetVpnGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.VpnGateway, error) {
	filter := bson.D{
		bson.E{"report_time", reportTime},
		bson.E{"vpn_gateway_id", id},
	}

	var result *ec2.VpnGateway
	err := dao.db.Collection("aws_ec2_vpn_gateways").FindOne(ctx, filter).Decode(&result)

	return result, err
}

func (dao *MongoEC2DAO) PutVpnGateways(ctx context.Context, resources []*ec2.VpnGateway) error {
	if len(resources) == 0 {
		return nil
	}
	writes := make([]interface{}, len(resources))
	for i, resource := range resources {
		writes[i] = resource
	}
	_, err := dao.db.Collection("aws.ec2.vpn_gateways").InsertMany(ctx, writes)

	return err
}

func (dao *MongoEC2DAO) GetVpnGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.db.Collection("aws_ec2_vpn_gateways"), reportDate)
}

func (dao *MongoEC2DAO) GetReferencedVpnGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.db.Collection("aws_ec2_vpn_gateways"), reportDate, timeSelection, timeReference)
}
