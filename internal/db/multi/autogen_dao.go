//AUTOGENERATED CODE DO NOT EDIT
// This file is automatically generated from /internal/codegen/templates/multi_dao.tmpl
package multi

import (
	"context"
	"fmt"
	"github.com/sheacloud/cloud-inventory/internal/db"
	"github.com/sheacloud/cloud-inventory/pkg/aws/acm"
	"github.com/sheacloud/cloud-inventory/pkg/aws/apigateway"
	"github.com/sheacloud/cloud-inventory/pkg/aws/apigatewayv2"
	"github.com/sheacloud/cloud-inventory/pkg/aws/applicationautoscaling"
	"github.com/sheacloud/cloud-inventory/pkg/aws/athena"
	"github.com/sheacloud/cloud-inventory/pkg/aws/autoscaling"
	"github.com/sheacloud/cloud-inventory/pkg/aws/backup"
	"github.com/sheacloud/cloud-inventory/pkg/aws/cloudformation"
	"github.com/sheacloud/cloud-inventory/pkg/aws/cloudfront"
	"github.com/sheacloud/cloud-inventory/pkg/aws/cloudtrail"
	"github.com/sheacloud/cloud-inventory/pkg/aws/cloudwatch"
	"github.com/sheacloud/cloud-inventory/pkg/aws/cloudwatchlogs"
	"github.com/sheacloud/cloud-inventory/pkg/aws/dynamodb"
	"github.com/sheacloud/cloud-inventory/pkg/aws/ec2"
	"github.com/sheacloud/cloud-inventory/pkg/aws/ecr"
	"github.com/sheacloud/cloud-inventory/pkg/aws/ecs"
	"github.com/sheacloud/cloud-inventory/pkg/aws/efs"
	"github.com/sheacloud/cloud-inventory/pkg/aws/elasticache"
	"github.com/sheacloud/cloud-inventory/pkg/aws/elasticloadbalancing"
	"github.com/sheacloud/cloud-inventory/pkg/aws/elasticloadbalancingv2"
	"github.com/sheacloud/cloud-inventory/pkg/aws/iam"
	"github.com/sheacloud/cloud-inventory/pkg/aws/kms"
	"github.com/sheacloud/cloud-inventory/pkg/aws/lambda"
	"github.com/sheacloud/cloud-inventory/pkg/aws/rds"
	"github.com/sheacloud/cloud-inventory/pkg/aws/redshift"
	"github.com/sheacloud/cloud-inventory/pkg/aws/route53"
	"github.com/sheacloud/cloud-inventory/pkg/aws/s3"
	"github.com/sheacloud/cloud-inventory/pkg/aws/secretsmanager"
	"github.com/sheacloud/cloud-inventory/pkg/aws/sns"
	"github.com/sheacloud/cloud-inventory/pkg/aws/sqs"
	"github.com/sheacloud/cloud-inventory/pkg/aws/ssm"
	"github.com/sheacloud/cloud-inventory/pkg/aws/storagegateway"
	"github.com/sheacloud/cloud-inventory/pkg/meta"
	"sync"
)

type MultiWriterDAO struct {
	daos []db.WriterDAO
}

func NewMultiWriterDAO(daos []db.WriterDAO) *MultiWriterDAO {
	return &MultiWriterDAO{
		daos: daos,
	}
}

func (dao *MultiWriterDAO) WriteInventoryResults(ctx context.Context, metadata *meta.InventoryResults) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.WriteInventoryResults(ctx, metadata)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}

func (dao *MultiWriterDAO) WriteIngestionTimestamp(ctx context.Context, metadata *meta.IngestionTimestamp) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.WriteIngestionTimestamp(ctx, metadata)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}

func (dao *MultiWriterDAO) FinishIndex(ctx context.Context, indices []string, reportDateUnixMilli int64) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.FinishIndex(ctx, indices, reportDateUnixMilli)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}

func (dao *MultiWriterDAO) Finish(ctx context.Context) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.Finish(ctx)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}

func (dao *MultiWriterDAO) PutAwsACMCertificates(ctx context.Context, resources []*acm.Certificate) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsACMCertificates(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsApiGatewayRestApis(ctx context.Context, resources []*apigateway.RestApi) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsApiGatewayRestApis(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsApiGatewayV2Apis(ctx context.Context, resources []*apigatewayv2.Api) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsApiGatewayV2Apis(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsApplicationAutoScalingScalingPolicies(ctx context.Context, resources []*applicationautoscaling.ScalingPolicy) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsApplicationAutoScalingScalingPolicies(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsAthenaWorkGroups(ctx context.Context, resources []*athena.WorkGroup) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsAthenaWorkGroups(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsAthenaDataCatalogs(ctx context.Context, resources []*athena.DataCatalog) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsAthenaDataCatalogs(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsAthenaDatabases(ctx context.Context, resources []*athena.Database) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsAthenaDatabases(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsAutoScalingAutoScalingGroups(ctx context.Context, resources []*autoscaling.AutoScalingGroup) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsAutoScalingAutoScalingGroups(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsAutoScalingLaunchConfigurations(ctx context.Context, resources []*autoscaling.LaunchConfiguration) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsAutoScalingLaunchConfigurations(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsBackupBackupVaults(ctx context.Context, resources []*backup.BackupVault) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsBackupBackupVaults(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsBackupBackupPlans(ctx context.Context, resources []*backup.BackupPlan) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsBackupBackupPlans(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsCloudFormationStacks(ctx context.Context, resources []*cloudformation.Stack) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsCloudFormationStacks(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsCloudFrontDistributions(ctx context.Context, resources []*cloudfront.Distribution) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsCloudFrontDistributions(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsCloudTrailTrails(ctx context.Context, resources []*cloudtrail.Trail) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsCloudTrailTrails(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsCloudWatchMetricAlarms(ctx context.Context, resources []*cloudwatch.MetricAlarm) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsCloudWatchMetricAlarms(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsCloudWatchCompositeAlarms(ctx context.Context, resources []*cloudwatch.CompositeAlarm) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsCloudWatchCompositeAlarms(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsCloudWatchLogsLogGroups(ctx context.Context, resources []*cloudwatchlogs.LogGroup) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsCloudWatchLogsLogGroups(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsDynamoDBTables(ctx context.Context, resources []*dynamodb.Table) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsDynamoDBTables(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2Addresses(ctx context.Context, resources []*ec2.Address) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2Addresses(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2DhcpOptions(ctx context.Context, resources []*ec2.DhcpOptions) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2DhcpOptions(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2Images(ctx context.Context, resources []*ec2.Image) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2Images(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2Instances(ctx context.Context, resources []*ec2.Instance) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2Instances(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2InternetGateways(ctx context.Context, resources []*ec2.InternetGateway) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2InternetGateways(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2ManagedPrefixLists(ctx context.Context, resources []*ec2.ManagedPrefixList) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2ManagedPrefixLists(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2NatGateways(ctx context.Context, resources []*ec2.NatGateway) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2NatGateways(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2NetworkAcls(ctx context.Context, resources []*ec2.NetworkAcl) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2NetworkAcls(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2NetworkInterfaces(ctx context.Context, resources []*ec2.NetworkInterface) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2NetworkInterfaces(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2PlacementGroups(ctx context.Context, resources []*ec2.PlacementGroup) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2PlacementGroups(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2ReservedInstances(ctx context.Context, resources []*ec2.ReservedInstances) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2ReservedInstances(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2RouteTables(ctx context.Context, resources []*ec2.RouteTable) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2RouteTables(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2SecurityGroups(ctx context.Context, resources []*ec2.SecurityGroup) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2SecurityGroups(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2Subnets(ctx context.Context, resources []*ec2.Subnet) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2Subnets(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2TransitGatewayPeeringAttachments(ctx context.Context, resources []*ec2.TransitGatewayPeeringAttachment) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2TransitGatewayPeeringAttachments(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2TransitGatewayRouteTables(ctx context.Context, resources []*ec2.TransitGatewayRouteTable) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2TransitGatewayRouteTables(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2TransitGatewayVpcAttachments(ctx context.Context, resources []*ec2.TransitGatewayVpcAttachment) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2TransitGatewayVpcAttachments(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2TransitGateways(ctx context.Context, resources []*ec2.TransitGateway) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2TransitGateways(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2Volumes(ctx context.Context, resources []*ec2.Volume) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2Volumes(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2VpcEndpoints(ctx context.Context, resources []*ec2.VpcEndpoint) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2VpcEndpoints(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2VpcPeeringConnections(ctx context.Context, resources []*ec2.VpcPeeringConnection) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2VpcPeeringConnections(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2Vpcs(ctx context.Context, resources []*ec2.Vpc) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2Vpcs(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEC2VpnGateways(ctx context.Context, resources []*ec2.VpnGateway) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEC2VpnGateways(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsECRRepositories(ctx context.Context, resources []*ecr.Repository) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsECRRepositories(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsECSClusters(ctx context.Context, resources []*ecs.Cluster) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsECSClusters(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsECSServices(ctx context.Context, resources []*ecs.Service) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsECSServices(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsECSTasks(ctx context.Context, resources []*ecs.Task) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsECSTasks(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsEFSFileSystems(ctx context.Context, resources []*efs.FileSystem) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsEFSFileSystems(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsElastiCacheCacheClusters(ctx context.Context, resources []*elasticache.CacheCluster) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsElastiCacheCacheClusters(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsElasticLoadBalancingLoadBalancers(ctx context.Context, resources []*elasticloadbalancing.LoadBalancer) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsElasticLoadBalancingLoadBalancers(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsElasticLoadBalancingV2LoadBalancers(ctx context.Context, resources []*elasticloadbalancingv2.LoadBalancer) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsElasticLoadBalancingV2LoadBalancers(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsElasticLoadBalancingV2TargetGroups(ctx context.Context, resources []*elasticloadbalancingv2.TargetGroup) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsElasticLoadBalancingV2TargetGroups(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsIAMGroups(ctx context.Context, resources []*iam.Group) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsIAMGroups(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsIAMPolicies(ctx context.Context, resources []*iam.Policy) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsIAMPolicies(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsIAMRoles(ctx context.Context, resources []*iam.Role) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsIAMRoles(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsIAMUsers(ctx context.Context, resources []*iam.User) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsIAMUsers(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsKMSKeys(ctx context.Context, resources []*kms.Key) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsKMSKeys(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsLambdaFunctions(ctx context.Context, resources []*lambda.Function) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsLambdaFunctions(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsRDSDBClusters(ctx context.Context, resources []*rds.DBCluster) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsRDSDBClusters(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsRDSDBInstances(ctx context.Context, resources []*rds.DBInstance) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsRDSDBInstances(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsRedshiftClusters(ctx context.Context, resources []*redshift.Cluster) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsRedshiftClusters(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsRoute53HostedZones(ctx context.Context, resources []*route53.HostedZone) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsRoute53HostedZones(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsS3Buckets(ctx context.Context, resources []*s3.Bucket) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsS3Buckets(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsSecretsManagerSecrets(ctx context.Context, resources []*secretsmanager.Secret) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsSecretsManagerSecrets(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsSNSTopics(ctx context.Context, resources []*sns.Topic) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsSNSTopics(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsSNSSubscriptions(ctx context.Context, resources []*sns.Subscription) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsSNSSubscriptions(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsSQSQueues(ctx context.Context, resources []*sqs.Queue) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsSQSQueues(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsSSMParameters(ctx context.Context, resources []*ssm.Parameter) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsSSMParameters(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
func (dao *MultiWriterDAO) PutAwsStorageGatewayGateways(ctx context.Context, resources []*storagegateway.Gateway) error {
	var wg sync.WaitGroup

	errors := []error{}
	errorLock := sync.Mutex{}
	for _, memberDao := range dao.daos {
		wg.Add(1)
		go func(memberDao db.WriterDAO) {
			defer wg.Done()
			err := memberDao.PutAwsStorageGatewayGateways(ctx, resources)
			if err != nil {
				errorLock.Lock()
				errors = append(errors, err)
				errorLock.Unlock()
			}
		}(memberDao)
	}

	wg.Wait()
	if len(errors) > 0 {
		return fmt.Errorf("%v", errors)
	}
	return nil
}
