//AUTOGENERATED CODE DO NOT EDIT
package dynamodb

import (
	"context"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	dynamo "github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/sheacloud/cloud-inventory/internal/db"
	"github.com/sheacloud/cloud-inventory/pkg/aws/iam"
	"time"
)

type DynamoDBIAMDAO struct {
	client     *dynamo.Client
	maxRetries int
}

func (dao *DynamoDBIAMDAO) ListGroups(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*iam.Group, error) {
	tableName := "cloud-inventory-aws-iam-groups"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "group_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*iam.Group
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBIAMDAO) GetGroup(ctx context.Context, reportTime time.Time, id string) (*iam.Group, error) {
	tableName := "cloud-inventory-aws-iam-groups"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "group_id")
	if err != nil {
		return nil, err
	}
	var resource *iam.Group
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBIAMDAO) PutGroups(ctx context.Context, resources []*iam.Group) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-iam-groups", items)
}

func (dao *DynamoDBIAMDAO) GetGroupReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "iam", "groups")
}

func (dao *DynamoDBIAMDAO) GetReferencedGroupReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "iam", "groups")
}

func (dao *DynamoDBIAMDAO) ListPolicies(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*iam.Policy, error) {
	tableName := "cloud-inventory-aws-iam-policies"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "policy_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*iam.Policy
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBIAMDAO) GetPolicy(ctx context.Context, reportTime time.Time, id string) (*iam.Policy, error) {
	tableName := "cloud-inventory-aws-iam-policies"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "policy_id")
	if err != nil {
		return nil, err
	}
	var resource *iam.Policy
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBIAMDAO) PutPolicies(ctx context.Context, resources []*iam.Policy) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-iam-policies", items)
}

func (dao *DynamoDBIAMDAO) GetPolicyReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "iam", "policies")
}

func (dao *DynamoDBIAMDAO) GetReferencedPolicyReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "iam", "policies")
}

func (dao *DynamoDBIAMDAO) ListRoles(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*iam.Role, error) {
	tableName := "cloud-inventory-aws-iam-roles"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "role_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*iam.Role
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBIAMDAO) GetRole(ctx context.Context, reportTime time.Time, id string) (*iam.Role, error) {
	tableName := "cloud-inventory-aws-iam-roles"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "role_id")
	if err != nil {
		return nil, err
	}
	var resource *iam.Role
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBIAMDAO) PutRoles(ctx context.Context, resources []*iam.Role) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-iam-roles", items)
}

func (dao *DynamoDBIAMDAO) GetRoleReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "iam", "roles")
}

func (dao *DynamoDBIAMDAO) GetReferencedRoleReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "iam", "roles")
}

func (dao *DynamoDBIAMDAO) ListUsers(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*iam.User, error) {
	tableName := "cloud-inventory-aws-iam-users"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "user_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*iam.User
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBIAMDAO) GetUser(ctx context.Context, reportTime time.Time, id string) (*iam.User, error) {
	tableName := "cloud-inventory-aws-iam-users"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "user_id")
	if err != nil {
		return nil, err
	}
	var resource *iam.User
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBIAMDAO) PutUsers(ctx context.Context, resources []*iam.User) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-iam-users", items)
}

func (dao *DynamoDBIAMDAO) GetUserReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "iam", "users")
}

func (dao *DynamoDBIAMDAO) GetReferencedUserReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "iam", "users")
}
