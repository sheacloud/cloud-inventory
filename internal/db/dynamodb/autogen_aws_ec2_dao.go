//AUTOGENERATED CODE DO NOT EDIT
package dynamodb

import (
	"context"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	dynamo "github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
	"github.com/sheacloud/cloud-inventory/internal/db"
	"github.com/sheacloud/cloud-inventory/pkg/aws/ec2"
	"time"
)

type DynamoDBEC2DAO struct {
	client     *dynamo.Client
	maxRetries int
}

func (dao *DynamoDBEC2DAO) ListAddresses(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Address, error) {
	tableName := "cloud-inventory-aws-ec2-addresses"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "allocation_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.Address
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetAddress(ctx context.Context, reportTime time.Time, id string) (*ec2.Address, error) {
	tableName := "cloud-inventory-aws-ec2-addresses"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "allocation_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.Address
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutAddresses(ctx context.Context, resources []*ec2.Address) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-addresses", items)
}

func (dao *DynamoDBEC2DAO) GetAddressReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "addresses")
}

func (dao *DynamoDBEC2DAO) GetReferencedAddressReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "addresses")
}

func (dao *DynamoDBEC2DAO) ListDhcpOptions(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.DhcpOptions, error) {
	tableName := "cloud-inventory-aws-ec2-dhcp-options"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "dhcp_options_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.DhcpOptions
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetDhcpOptions(ctx context.Context, reportTime time.Time, id string) (*ec2.DhcpOptions, error) {
	tableName := "cloud-inventory-aws-ec2-dhcp-options"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "dhcp_options_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.DhcpOptions
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutDhcpOptions(ctx context.Context, resources []*ec2.DhcpOptions) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-dhcp-options", items)
}

func (dao *DynamoDBEC2DAO) GetDhcpOptionsReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "dhcp_options")
}

func (dao *DynamoDBEC2DAO) GetReferencedDhcpOptionsReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "dhcp_options")
}

func (dao *DynamoDBEC2DAO) ListImages(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Image, error) {
	tableName := "cloud-inventory-aws-ec2-images"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "image_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.Image
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetImage(ctx context.Context, reportTime time.Time, id string) (*ec2.Image, error) {
	tableName := "cloud-inventory-aws-ec2-images"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "image_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.Image
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutImages(ctx context.Context, resources []*ec2.Image) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-images", items)
}

func (dao *DynamoDBEC2DAO) GetImageReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "images")
}

func (dao *DynamoDBEC2DAO) GetReferencedImageReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "images")
}

func (dao *DynamoDBEC2DAO) ListInstances(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Instance, error) {
	tableName := "cloud-inventory-aws-ec2-instances"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "instance_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.Instance
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetInstance(ctx context.Context, reportTime time.Time, id string) (*ec2.Instance, error) {
	tableName := "cloud-inventory-aws-ec2-instances"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "instance_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.Instance
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutInstances(ctx context.Context, resources []*ec2.Instance) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-instances", items)
}

func (dao *DynamoDBEC2DAO) GetInstanceReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "instances")
}

func (dao *DynamoDBEC2DAO) GetReferencedInstanceReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "instances")
}

func (dao *DynamoDBEC2DAO) ListInternetGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.InternetGateway, error) {
	tableName := "cloud-inventory-aws-ec2-internet-gateways"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "internet_gateway_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.InternetGateway
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetInternetGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.InternetGateway, error) {
	tableName := "cloud-inventory-aws-ec2-internet-gateways"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "internet_gateway_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.InternetGateway
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutInternetGateways(ctx context.Context, resources []*ec2.InternetGateway) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-internet-gateways", items)
}

func (dao *DynamoDBEC2DAO) GetInternetGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "internet_gateways")
}

func (dao *DynamoDBEC2DAO) GetReferencedInternetGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "internet_gateways")
}

func (dao *DynamoDBEC2DAO) ListManagedPrefixLists(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.ManagedPrefixList, error) {
	tableName := "cloud-inventory-aws-ec2-managed-prefix-lists"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "prefix_list_arn", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.ManagedPrefixList
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetManagedPrefixList(ctx context.Context, reportTime time.Time, id string) (*ec2.ManagedPrefixList, error) {
	tableName := "cloud-inventory-aws-ec2-managed-prefix-lists"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "prefix_list_arn")
	if err != nil {
		return nil, err
	}
	var resource *ec2.ManagedPrefixList
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutManagedPrefixLists(ctx context.Context, resources []*ec2.ManagedPrefixList) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-managed-prefix-lists", items)
}

func (dao *DynamoDBEC2DAO) GetManagedPrefixListReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "managed_prefix_lists")
}

func (dao *DynamoDBEC2DAO) GetReferencedManagedPrefixListReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "managed_prefix_lists")
}

func (dao *DynamoDBEC2DAO) ListNatGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.NatGateway, error) {
	tableName := "cloud-inventory-aws-ec2-nat-gateways"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "nat_gateway_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.NatGateway
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetNatGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.NatGateway, error) {
	tableName := "cloud-inventory-aws-ec2-nat-gateways"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "nat_gateway_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.NatGateway
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutNatGateways(ctx context.Context, resources []*ec2.NatGateway) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-nat-gateways", items)
}

func (dao *DynamoDBEC2DAO) GetNatGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "nat_gateways")
}

func (dao *DynamoDBEC2DAO) GetReferencedNatGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "nat_gateways")
}

func (dao *DynamoDBEC2DAO) ListNetworkAcls(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.NetworkAcl, error) {
	tableName := "cloud-inventory-aws-ec2-network-acls"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "network_acl_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.NetworkAcl
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetNetworkAcl(ctx context.Context, reportTime time.Time, id string) (*ec2.NetworkAcl, error) {
	tableName := "cloud-inventory-aws-ec2-network-acls"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "network_acl_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.NetworkAcl
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutNetworkAcls(ctx context.Context, resources []*ec2.NetworkAcl) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-network-acls", items)
}

func (dao *DynamoDBEC2DAO) GetNetworkAclReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "network_acls")
}

func (dao *DynamoDBEC2DAO) GetReferencedNetworkAclReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "network_acls")
}

func (dao *DynamoDBEC2DAO) ListNetworkInterfaces(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.NetworkInterface, error) {
	tableName := "cloud-inventory-aws-ec2-network-interfaces"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "network_interface_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.NetworkInterface
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetNetworkInterface(ctx context.Context, reportTime time.Time, id string) (*ec2.NetworkInterface, error) {
	tableName := "cloud-inventory-aws-ec2-network-interfaces"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "network_interface_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.NetworkInterface
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutNetworkInterfaces(ctx context.Context, resources []*ec2.NetworkInterface) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-network-interfaces", items)
}

func (dao *DynamoDBEC2DAO) GetNetworkInterfaceReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "network_interfaces")
}

func (dao *DynamoDBEC2DAO) GetReferencedNetworkInterfaceReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "network_interfaces")
}

func (dao *DynamoDBEC2DAO) ListPlacementGroups(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.PlacementGroup, error) {
	tableName := "cloud-inventory-aws-ec2-placement-groups"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "group_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.PlacementGroup
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetPlacementGroup(ctx context.Context, reportTime time.Time, id string) (*ec2.PlacementGroup, error) {
	tableName := "cloud-inventory-aws-ec2-placement-groups"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "group_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.PlacementGroup
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutPlacementGroups(ctx context.Context, resources []*ec2.PlacementGroup) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-placement-groups", items)
}

func (dao *DynamoDBEC2DAO) GetPlacementGroupReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "placement_groups")
}

func (dao *DynamoDBEC2DAO) GetReferencedPlacementGroupReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "placement_groups")
}

func (dao *DynamoDBEC2DAO) ListReservedInstances(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.ReservedInstances, error) {
	tableName := "cloud-inventory-aws-ec2-reserved-instances"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "reserved_instances_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.ReservedInstances
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetReservedInstances(ctx context.Context, reportTime time.Time, id string) (*ec2.ReservedInstances, error) {
	tableName := "cloud-inventory-aws-ec2-reserved-instances"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "reserved_instances_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.ReservedInstances
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutReservedInstances(ctx context.Context, resources []*ec2.ReservedInstances) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-reserved-instances", items)
}

func (dao *DynamoDBEC2DAO) GetReservedInstancesReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "reserved_instances")
}

func (dao *DynamoDBEC2DAO) GetReferencedReservedInstancesReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "reserved_instances")
}

func (dao *DynamoDBEC2DAO) ListRouteTables(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.RouteTable, error) {
	tableName := "cloud-inventory-aws-ec2-route-tables"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "route_table_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.RouteTable
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetRouteTable(ctx context.Context, reportTime time.Time, id string) (*ec2.RouteTable, error) {
	tableName := "cloud-inventory-aws-ec2-route-tables"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "route_table_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.RouteTable
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutRouteTables(ctx context.Context, resources []*ec2.RouteTable) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-route-tables", items)
}

func (dao *DynamoDBEC2DAO) GetRouteTableReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "route_tables")
}

func (dao *DynamoDBEC2DAO) GetReferencedRouteTableReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "route_tables")
}

func (dao *DynamoDBEC2DAO) ListSecurityGroups(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.SecurityGroup, error) {
	tableName := "cloud-inventory-aws-ec2-security-groups"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "group_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.SecurityGroup
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetSecurityGroup(ctx context.Context, reportTime time.Time, id string) (*ec2.SecurityGroup, error) {
	tableName := "cloud-inventory-aws-ec2-security-groups"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "group_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.SecurityGroup
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutSecurityGroups(ctx context.Context, resources []*ec2.SecurityGroup) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-security-groups", items)
}

func (dao *DynamoDBEC2DAO) GetSecurityGroupReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "security_groups")
}

func (dao *DynamoDBEC2DAO) GetReferencedSecurityGroupReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "security_groups")
}

func (dao *DynamoDBEC2DAO) ListSubnets(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Subnet, error) {
	tableName := "cloud-inventory-aws-ec2-subnets"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "subnet_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.Subnet
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetSubnet(ctx context.Context, reportTime time.Time, id string) (*ec2.Subnet, error) {
	tableName := "cloud-inventory-aws-ec2-subnets"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "subnet_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.Subnet
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutSubnets(ctx context.Context, resources []*ec2.Subnet) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-subnets", items)
}

func (dao *DynamoDBEC2DAO) GetSubnetReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "subnets")
}

func (dao *DynamoDBEC2DAO) GetReferencedSubnetReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "subnets")
}

func (dao *DynamoDBEC2DAO) ListTransitGatewayPeeringAttachments(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGatewayPeeringAttachment, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateway-peering-attachments"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "transit_gateway_attachment_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.TransitGatewayPeeringAttachment
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetTransitGatewayPeeringAttachment(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGatewayPeeringAttachment, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateway-peering-attachments"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "transit_gateway_attachment_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.TransitGatewayPeeringAttachment
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutTransitGatewayPeeringAttachments(ctx context.Context, resources []*ec2.TransitGatewayPeeringAttachment) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-transit-gateway-peering-attachments", items)
}

func (dao *DynamoDBEC2DAO) GetTransitGatewayPeeringAttachmentReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "transit_gateway_peering_attachments")
}

func (dao *DynamoDBEC2DAO) GetReferencedTransitGatewayPeeringAttachmentReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "transit_gateway_peering_attachments")
}

func (dao *DynamoDBEC2DAO) ListTransitGatewayRouteTables(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGatewayRouteTable, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateway-route-tables"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "transit_gateway_route_table_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.TransitGatewayRouteTable
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetTransitGatewayRouteTable(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGatewayRouteTable, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateway-route-tables"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "transit_gateway_route_table_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.TransitGatewayRouteTable
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutTransitGatewayRouteTables(ctx context.Context, resources []*ec2.TransitGatewayRouteTable) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-transit-gateway-route-tables", items)
}

func (dao *DynamoDBEC2DAO) GetTransitGatewayRouteTableReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "transit_gateway_route_tables")
}

func (dao *DynamoDBEC2DAO) GetReferencedTransitGatewayRouteTableReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "transit_gateway_route_tables")
}

func (dao *DynamoDBEC2DAO) ListTransitGatewayVpcAttachments(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGatewayVpcAttachment, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateway-vpc-attachments"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "transit_gateway_attachment_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.TransitGatewayVpcAttachment
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetTransitGatewayVpcAttachment(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGatewayVpcAttachment, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateway-vpc-attachments"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "transit_gateway_attachment_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.TransitGatewayVpcAttachment
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutTransitGatewayVpcAttachments(ctx context.Context, resources []*ec2.TransitGatewayVpcAttachment) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-transit-gateway-vpc-attachments", items)
}

func (dao *DynamoDBEC2DAO) GetTransitGatewayVpcAttachmentReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "transit_gateway_vpc_attachments")
}

func (dao *DynamoDBEC2DAO) GetReferencedTransitGatewayVpcAttachmentReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "transit_gateway_vpc_attachments")
}

func (dao *DynamoDBEC2DAO) ListTransitGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.TransitGateway, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateways"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "transit_gateway_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.TransitGateway
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetTransitGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.TransitGateway, error) {
	tableName := "cloud-inventory-aws-ec2-transit-gateways"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "transit_gateway_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.TransitGateway
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutTransitGateways(ctx context.Context, resources []*ec2.TransitGateway) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-transit-gateways", items)
}

func (dao *DynamoDBEC2DAO) GetTransitGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "transit_gateways")
}

func (dao *DynamoDBEC2DAO) GetReferencedTransitGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "transit_gateways")
}

func (dao *DynamoDBEC2DAO) ListVolumes(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Volume, error) {
	tableName := "cloud-inventory-aws-ec2-volumes"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "volume_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.Volume
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetVolume(ctx context.Context, reportTime time.Time, id string) (*ec2.Volume, error) {
	tableName := "cloud-inventory-aws-ec2-volumes"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "volume_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.Volume
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutVolumes(ctx context.Context, resources []*ec2.Volume) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-volumes", items)
}

func (dao *DynamoDBEC2DAO) GetVolumeReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "volumes")
}

func (dao *DynamoDBEC2DAO) GetReferencedVolumeReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "volumes")
}

func (dao *DynamoDBEC2DAO) ListVpcEndpoints(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.VpcEndpoint, error) {
	tableName := "cloud-inventory-aws-ec2-vpc-endpoints"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "vpc_endpoint_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.VpcEndpoint
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetVpcEndpoint(ctx context.Context, reportTime time.Time, id string) (*ec2.VpcEndpoint, error) {
	tableName := "cloud-inventory-aws-ec2-vpc-endpoints"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "vpc_endpoint_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.VpcEndpoint
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutVpcEndpoints(ctx context.Context, resources []*ec2.VpcEndpoint) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-vpc-endpoints", items)
}

func (dao *DynamoDBEC2DAO) GetVpcEndpointReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "vpc_endpoints")
}

func (dao *DynamoDBEC2DAO) GetReferencedVpcEndpointReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "vpc_endpoints")
}

func (dao *DynamoDBEC2DAO) ListVpcPeeringConnections(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.VpcPeeringConnection, error) {
	tableName := "cloud-inventory-aws-ec2-vpc-peering-connections"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "vpc_peering_connection_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.VpcPeeringConnection
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetVpcPeeringConnection(ctx context.Context, reportTime time.Time, id string) (*ec2.VpcPeeringConnection, error) {
	tableName := "cloud-inventory-aws-ec2-vpc-peering-connections"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "vpc_peering_connection_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.VpcPeeringConnection
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutVpcPeeringConnections(ctx context.Context, resources []*ec2.VpcPeeringConnection) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-vpc-peering-connections", items)
}

func (dao *DynamoDBEC2DAO) GetVpcPeeringConnectionReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "vpc_peering_connections")
}

func (dao *DynamoDBEC2DAO) GetReferencedVpcPeeringConnectionReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "vpc_peering_connections")
}

func (dao *DynamoDBEC2DAO) ListVpcs(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.Vpc, error) {
	tableName := "cloud-inventory-aws-ec2-vpcs"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "vpc_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.Vpc
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetVpc(ctx context.Context, reportTime time.Time, id string) (*ec2.Vpc, error) {
	tableName := "cloud-inventory-aws-ec2-vpcs"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "vpc_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.Vpc
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutVpcs(ctx context.Context, resources []*ec2.Vpc) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-vpcs", items)
}

func (dao *DynamoDBEC2DAO) GetVpcReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "vpcs")
}

func (dao *DynamoDBEC2DAO) GetReferencedVpcReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "vpcs")
}

func (dao *DynamoDBEC2DAO) ListVpnGateways(ctx context.Context, reportTime time.Time, accountID, region *string, limit, offset *int64) ([]*ec2.VpnGateway, error) {
	tableName := "cloud-inventory-aws-ec2-vpn-gateways"
	items, _, err := ListItems(ctx, dao.client, tableName, reportTime, "vpn_gateway_id", nil)
	if err != nil {
		return nil, err
	}
	var resources []*ec2.VpnGateway
	err = attributevalue.UnmarshalListOfMaps(items, &resources)
	if err != nil {
		return nil, err
	}
	return resources, nil
}

func (dao *DynamoDBEC2DAO) GetVpnGateway(ctx context.Context, reportTime time.Time, id string) (*ec2.VpnGateway, error) {
	tableName := "cloud-inventory-aws-ec2-vpn-gateways"
	item, err := GetItem(ctx, dao.client, tableName, reportTime, id, "vpn_gateway_id")
	if err != nil {
		return nil, err
	}
	var resource *ec2.VpnGateway
	err = attributevalue.UnmarshalMap(item, &resource)
	if err != nil {
		return nil, err
	}
	return resource, nil
}

func (dao *DynamoDBEC2DAO) PutVpnGateways(ctx context.Context, resources []*ec2.VpnGateway) error {
	items := make([]map[string]types.AttributeValue, len(resources))
	for i, resource := range resources {
		item, err := attributevalue.MarshalMap(resource)
		if err != nil {
			return err
		}
		items[i] = item
	}
	return BatchWriteItems(ctx, dao.client, dao.maxRetries, "cloud-inventory-aws-ec2-vpn-gateways", items)
}

func (dao *DynamoDBEC2DAO) GetVpnGatewayReportTimes(ctx context.Context, reportDate time.Time) ([]string, error) {
	return DistinctReportTimes(ctx, dao.client, reportDate, "aws", "ec2", "vpn_gateways")
}

func (dao *DynamoDBEC2DAO) GetReferencedVpnGatewayReportTime(ctx context.Context, reportDate time.Time, timeSelection db.TimeSelection, timeReference time.Time) (*time.Time, error) {
	return GetReportTime(ctx, dao.client, reportDate, timeSelection, timeReference, "aws", "ec2", "vpn_gateways")
}
