// AUTOGENERATED, DO NOT EDIT
package ec2

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/ec2"
	"github.com/jinzhu/copier"
	"github.com/sheacloud/cloud-inventory/internal/storage"
	"github.com/sirupsen/logrus"
)

var customReservedInstancesModelPostprocessingFuncs []func(x *ReservedInstancesModel) = []func(x *ReservedInstancesModel){}
var customReservedInstancesModelFuncsLock sync.Mutex

func registerCustomReservedInstancesModelPostprocessingFunc(f func(x *ReservedInstancesModel)) {
	customReservedInstancesModelFuncsLock.Lock()
	defer customReservedInstancesModelFuncsLock.Unlock()

	customReservedInstancesModelPostprocessingFuncs = append(customReservedInstancesModelPostprocessingFuncs, f)
}

func init() {
	Controller.RegisterDataSource("reserved_instances", ReservedInstancesDataSource)
}

type ReservedInstancesModel struct {
	AvailabilityZone    string `parquet:"name=availability_zone,type=BYTE_ARRAY,convertedtype=UTF8"`
	CurrencyCode        string `parquet:"name=currency_code,type=BYTE_ARRAY,convertedtype=UTF8"`
	Duration            int64  `parquet:"name=duration,type=INT64"`
	End                 *time.Time
	EndMilli            int64                                    `parquet:"name=end, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	FixedPrice          float32                                  `parquet:"name=fixed_price,type=FLOAT"`
	InstanceCount       int32                                    `parquet:"name=instance_count,type=INT32"`
	InstanceTenancy     string                                   `parquet:"name=instance_tenancy,type=BYTE_ARRAY,convertedtype=UTF8"`
	InstanceType        string                                   `parquet:"name=instance_type,type=BYTE_ARRAY,convertedtype=UTF8"`
	OfferingClass       string                                   `parquet:"name=offering_class,type=BYTE_ARRAY,convertedtype=UTF8"`
	OfferingType        string                                   `parquet:"name=offering_type,type=BYTE_ARRAY,convertedtype=UTF8"`
	ProductDescription  string                                   `parquet:"name=product_description,type=BYTE_ARRAY,convertedtype=UTF8"`
	RecurringCharges    []*RecurringChargeReservedInstancesModel `parquet:"name=recurring_charges,type=LIST"`
	ReservedInstancesId string                                   `parquet:"name=reserved_instances_id,type=BYTE_ARRAY,convertedtype=UTF8" inventory_primary_key:"true"`
	Scope               string                                   `parquet:"name=scope,type=BYTE_ARRAY,convertedtype=UTF8"`
	Start               *time.Time
	StartMilli          int64             `parquet:"name=start, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	State               string            `parquet:"name=state,type=BYTE_ARRAY,convertedtype=UTF8"`
	Tags                map[string]string `parquet:"name=tags,type=MAP,keytype=BYTE_ARRAY,valuetype=BYTE_ARRAY,keyconvertedtype=UTF8,valueconvertedtype=UTF8"`
	UsagePrice          float32           `parquet:"name=usage_price,type=FLOAT"`
	AccountId           string            `parquet:"name=account_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	Region              string            `parquet:"name=region, type=BYTE_ARRAY, convertedtype=UTF8"`
	ReportTime          int64             `parquet:"name=report_time, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
}

type RecurringChargeReservedInstancesModel struct {
	Amount    float64 `parquet:"name=amount,type=DOUBLE"`
	Frequency string  `parquet:"name=frequency,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type TagReservedInstancesModel struct {
	Key   string `parquet:"name=key,type=BYTE_ARRAY,convertedtype=UTF8"`
	Value string `parquet:"name=value,type=BYTE_ARRAY,convertedtype=UTF8"`
}

func ReservedInstancesDataSource(ctx context.Context, client *ec2.Client, reportTime time.Time, storageConfig storage.StorageContextConfig, storageManager *storage.StorageManager) error {
	storageContextSet, err := storageManager.GetStorageContextSet(storageConfig, new(ReservedInstancesModel))
	if err != nil {
		return err
	}
	defer storageContextSet.Close(ctx)

	params := &ec2.DescribeReservedInstancesInput{}

	result, err := client.DescribeReservedInstances(ctx, params)
	if err != nil {
		logrus.WithFields(logrus.Fields{
			"service":     storageConfig.Service,
			"data_source": storageConfig.DataSource,
			"account_id":  storageConfig.AccountId,
			"region":      storageConfig.Region,
			"cloud":       storageConfig.Cloud,
			"error":       err,
		}).Error("error calling DescribeReservedInstances")
		return err
	}

	results := []*ec2.DescribeReservedInstancesOutput{result}
	for _, output := range results {

		for _, var0 := range output.ReservedInstances {

			model := new(ReservedInstancesModel)
			copier.Copy(&model, &var0)

			model.Tags = GetTagMap(var0.Tags)
			model.AccountId = storageConfig.AccountId
			model.Region = storageConfig.Region
			model.ReportTime = reportTime.UTC().UnixMilli()

			for _, f := range customReservedInstancesModelPostprocessingFuncs {
				f(model)
			}

			errors := storageContextSet.Store(ctx, model)
			for storageContext, err := range errors {
				storage.LogContextError(storageContext, fmt.Sprintf("Error storing ReservedInstancesModel: %v", err))
			}
		}

	}

	return nil
}
