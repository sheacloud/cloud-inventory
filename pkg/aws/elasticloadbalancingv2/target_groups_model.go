// AUTOGENERATED, DO NOT EDIT
package elasticloadbalancingv2

import (
	"fmt"
	"github.com/jinzhu/copier"
	"github.com/sheacloud/cloud-inventory/internal/storage"
	"github.com/sirupsen/logrus"
	"time"

	"context"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2"
	"sync"
)

var customTargetGroupModelPostprocessingFuncs []func(ctx context.Context, client *elasticloadbalancingv2.Client, cfg aws.Config, x *TargetGroupModel) = []func(ctx context.Context, client *elasticloadbalancingv2.Client, cfg aws.Config, x *TargetGroupModel){}
var customTargetGroupModelFuncsLock sync.Mutex

func registerCustomTargetGroupModelPostprocessingFunc(f func(ctx context.Context, client *elasticloadbalancingv2.Client, cfg aws.Config, x *TargetGroupModel)) {
	customTargetGroupModelFuncsLock.Lock()
	defer customTargetGroupModelFuncsLock.Unlock()

	customTargetGroupModelPostprocessingFuncs = append(customTargetGroupModelPostprocessingFuncs, f)
}

func init() {
	Controller.RegisterDataSource("target_groups", TargetGroupDataSource)
}

type TargetGroupModel struct {
	HealthCheckEnabled         bool                                       `parquet:"name=health_check_enabled,type=BOOLEAN"`
	HealthCheckIntervalSeconds int32                                      `parquet:"name=health_check_interval_seconds,type=INT32"`
	HealthCheckPath            string                                     `parquet:"name=health_check_path,type=BYTE_ARRAY,convertedtype=UTF8"`
	HealthCheckPort            string                                     `parquet:"name=health_check_port,type=BYTE_ARRAY,convertedtype=UTF8"`
	HealthCheckProtocol        string                                     `parquet:"name=health_check_protocol,type=BYTE_ARRAY,convertedtype=UTF8"`
	HealthCheckTimeoutSeconds  int32                                      `parquet:"name=health_check_timeout_seconds,type=INT32"`
	HealthyThresholdCount      int32                                      `parquet:"name=healthy_threshold_count,type=INT32"`
	LoadBalancerArns           []string                                   `parquet:"name=load_balancer_arns,type=MAP,convertedtype=LIST,valuetype=BYTE_ARRAY,valueconvertedtype=UTF8"`
	Matcher                    *MatcherTargetGroupModel                   `parquet:"name=matcher"`
	Port                       int32                                      `parquet:"name=port,type=INT32"`
	Protocol                   string                                     `parquet:"name=protocol,type=BYTE_ARRAY,convertedtype=UTF8"`
	ProtocolVersion            string                                     `parquet:"name=protocol_version,type=BYTE_ARRAY,convertedtype=UTF8"`
	TargetGroupArn             string                                     `parquet:"name=target_group_arn,type=BYTE_ARRAY,convertedtype=UTF8" inventory_primary_key:"true"`
	TargetGroupName            string                                     `parquet:"name=target_group_name,type=BYTE_ARRAY,convertedtype=UTF8"`
	TargetType                 string                                     `parquet:"name=target_type,type=BYTE_ARRAY,convertedtype=UTF8"`
	UnhealthyThresholdCount    int32                                      `parquet:"name=unhealthy_threshold_count,type=INT32"`
	VpcId                      string                                     `parquet:"name=vpc_id,type=BYTE_ARRAY,convertedtype=UTF8"`
	AccountId                  string                                     `parquet:"name=account_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	Region                     string                                     `parquet:"name=region, type=BYTE_ARRAY, convertedtype=UTF8"`
	ReportTime                 int64                                      `parquet:"name=report_time, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	Targets                    []*TargetHealthDescriptionTargetGroupModel `parquet:"name=targets,type=LIST"`
	Tags                       map[string]string                          `parquet:"name=tags,type=MAP,keytype=BYTE_ARRAY,valuetype=BYTE_ARRAY,keyconvertedtype=UTF8,valueconvertedtype=UTF8"`
}

type MatcherTargetGroupModel struct {
	GrpcCode string `parquet:"name=grpc_code,type=BYTE_ARRAY,convertedtype=UTF8"`
	HttpCode string `parquet:"name=http_code,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type TargetHealthDescriptionTargetGroupModel struct {
	HealthCheckPort string                             `parquet:"name=health_check_port,type=BYTE_ARRAY,convertedtype=UTF8"`
	Target          *TargetDescriptionTargetGroupModel `parquet:"name=target"`
	TargetHealth    *TargetHealthTargetGroupModel      `parquet:"name=target_health"`
}

type TargetDescriptionTargetGroupModel struct {
	Id               string `parquet:"name=id,type=BYTE_ARRAY,convertedtype=UTF8"`
	AvailabilityZone string `parquet:"name=availability_zone,type=BYTE_ARRAY,convertedtype=UTF8"`
	Port             int32  `parquet:"name=port,type=INT32"`
}

type TargetHealthTargetGroupModel struct {
	Description string `parquet:"name=description,type=BYTE_ARRAY,convertedtype=UTF8"`
	Reason      string `parquet:"name=reason,type=BYTE_ARRAY,convertedtype=UTF8"`
	State       string `parquet:"name=state,type=BYTE_ARRAY,convertedtype=UTF8"`
}

func TargetGroupDataSource(ctx context.Context, client *elasticloadbalancingv2.Client, cfg aws.Config, reportTime time.Time, storageConfig storage.StorageContextConfig, storageManager *storage.StorageManager) error {
	storageContextSet, err := storageManager.GetStorageContextSet(storageConfig, new(TargetGroupModel))
	if err != nil {
		return err
	}
	defer storageContextSet.Close(ctx)

	paginator := elasticloadbalancingv2.NewDescribeTargetGroupsPaginator(client, &elasticloadbalancingv2.DescribeTargetGroupsInput{})

	for paginator.HasMorePages() {
		output, err := paginator.NextPage(ctx)
		if err != nil {
			logrus.WithFields(logrus.Fields{
				"service":     storageConfig.Service,
				"data_source": storageConfig.DataSource,
				"account_id":  storageConfig.AccountId,
				"region":      storageConfig.Region,
				"cloud":       storageConfig.Cloud,
				"error":       err,
			}).Error("error calling DescribeTargetGroups")
			return err
		}

		for _, var0 := range output.TargetGroups {

			model := new(TargetGroupModel)
			copier.Copy(&model, &var0)

			model.AccountId = storageConfig.AccountId
			model.Region = storageConfig.Region
			model.ReportTime = reportTime.UTC().UnixMilli()

			for _, f := range customTargetGroupModelPostprocessingFuncs {
				f(ctx, client, cfg, model)
			}

			errors := storageContextSet.Store(ctx, model)
			for storageContext, err := range errors {
				storage.LogContextError(storageContext, fmt.Sprintf("Error storing TargetGroupModel: %v", err))
			}
		}

	}

	return nil
}
