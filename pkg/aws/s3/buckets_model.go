// AUTOGENERATED, DO NOT EDIT
package s3

import (
	"fmt"
	"github.com/jinzhu/copier"
	"github.com/sheacloud/cloud-inventory/internal/storage"
	"github.com/sirupsen/logrus"
	"time"

	"context"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"sync"
)

var customBucketModelPostprocessingFuncs []func(ctx context.Context, client *s3.Client, cfg aws.Config, x *BucketModel) = []func(ctx context.Context, client *s3.Client, cfg aws.Config, x *BucketModel){}
var customBucketModelFuncsLock sync.Mutex

func registerCustomBucketModelPostprocessingFunc(f func(ctx context.Context, client *s3.Client, cfg aws.Config, x *BucketModel)) {
	customBucketModelFuncsLock.Lock()
	defer customBucketModelFuncsLock.Unlock()

	customBucketModelPostprocessingFuncs = append(customBucketModelPostprocessingFuncs, f)
}

func init() {
	Controller.RegisterDataSource("buckets", BucketDataSource)
}

type BucketModel struct {
	CreationDate                      *time.Time
	CreationDateMilli                 int64                                         `parquet:"name=creation_date, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	Name                              string                                        `parquet:"name=name,type=BYTE_ARRAY,convertedtype=UTF8" inventory_primary_key:"true"`
	AccountId                         string                                        `parquet:"name=account_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	Region                            string                                        `parquet:"name=region, type=BYTE_ARRAY, convertedtype=UTF8"`
	ReportTime                        int64                                         `parquet:"name=report_time, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	ReplicationConfiguration          *ReplicationConfigurationBucketModel          `parquet:"name=replication_configuration"`
	AclGrants                         []*GrantBucketModel                           `parquet:"name=acl_grants,type=LIST"`
	CorsRules                         []*CORSRuleBucketModel                        `parquet:"name=cors_rules,type=LIST"`
	ServerSideEncryptionConfiguration *ServerSideEncryptionConfigurationBucketModel `parquet:"name=server_side_encryption_configuration"`
	IntelligentTieringConfigurations  []*IntelligentTieringConfigurationBucketModel `parquet:"name=intelligent_tiering_configurations,type=LIST"`
	InventoryConfigurations           []*InventoryConfigurationBucketModel          `parquet:"name=inventory_configurations,type=LIST"`
	LifecycleRules                    []*LifecycleRuleBucketModel                   `parquet:"name=lifecycle_rules,type=LIST"`
	Logging                           *LoggingEnabledBucketModel                    `parquet:"name=logging"`
	Policy                            string                                        `parquet:"name=policy,type=BYTE_ARRAY,convertedtype=UTF8"`
	IsPublic                          bool                                          `parquet:"name=is_public,type=BOOLEAN"`
	Tags                              map[string]string                             `parquet:"name=tags,type=MAP,keytype=BYTE_ARRAY,valuetype=BYTE_ARRAY,keyconvertedtype=UTF8,valueconvertedtype=UTF8"`
	VersioningStatus                  string                                        `parquet:"name=versioning_status,type=BYTE_ARRAY,convertedtype=UTF8"`
	MFADeleteStatus                   string                                        `parquet:"name=mfa_delete_status,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type ReplicationConfigurationBucketModel struct {
	Role  string                        `parquet:"name=role,type=BYTE_ARRAY,convertedtype=UTF8"`
	Rules []*ReplicationRuleBucketModel `parquet:"name=rules,type=LIST"`
}

type ReplicationRuleBucketModel struct {
	Destination               *DestinationBucketModel               `parquet:"name=destination"`
	Status                    string                                `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
	DeleteMarkerReplication   *DeleteMarkerReplicationBucketModel   `parquet:"name=delete_marker_replication"`
	ExistingObjectReplication *ExistingObjectReplicationBucketModel `parquet:"name=existing_object_replication"`
	ID                        string                                `parquet:"name=id,type=BYTE_ARRAY,convertedtype=UTF8"`
	Prefix                    string                                `parquet:"name=prefix,type=BYTE_ARRAY,convertedtype=UTF8"`
	Priority                  int32                                 `parquet:"name=priority,type=INT32"`
	SourceSelectionCriteria   *SourceSelectionCriteriaBucketModel   `parquet:"name=source_selection_criteria"`
}

type DestinationBucketModel struct {
	Bucket                   string                               `parquet:"name=bucket,type=BYTE_ARRAY,convertedtype=UTF8"`
	AccessControlTranslation *AccessControlTranslationBucketModel `parquet:"name=access_control_translation"`
	Account                  string                               `parquet:"name=account,type=BYTE_ARRAY,convertedtype=UTF8"`
	EncryptionConfiguration  *EncryptionConfigurationBucketModel  `parquet:"name=encryption_configuration"`
	Metrics                  *MetricsBucketModel                  `parquet:"name=metrics"`
	ReplicationTime          *ReplicationTimeBucketModel          `parquet:"name=replication_time"`
	StorageClass             string                               `parquet:"name=storage_class,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type AccessControlTranslationBucketModel struct {
	Owner string `parquet:"name=owner,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type EncryptionConfigurationBucketModel struct {
	ReplicaKmsKeyID string `parquet:"name=replica_kms_key_id,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type MetricsBucketModel struct {
	Status         string                           `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
	EventThreshold *ReplicationTimeValueBucketModel `parquet:"name=event_threshold"`
}

type ReplicationTimeValueBucketModel struct {
	Minutes int32 `parquet:"name=minutes,type=INT32"`
}

type ReplicationTimeBucketModel struct {
	Status string                           `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
	Time   *ReplicationTimeValueBucketModel `parquet:"name=time"`
}

type DeleteMarkerReplicationBucketModel struct {
	Status string `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type ExistingObjectReplicationBucketModel struct {
	Status string `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type SourceSelectionCriteriaBucketModel struct {
	ReplicaModifications   *ReplicaModificationsBucketModel   `parquet:"name=replica_modifications"`
	SseKmsEncryptedObjects *SseKmsEncryptedObjectsBucketModel `parquet:"name=sse_kms_encrypted_objects"`
}

type ReplicaModificationsBucketModel struct {
	Status string `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type SseKmsEncryptedObjectsBucketModel struct {
	Status string `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type GrantBucketModel struct {
	Grantee    *GranteeBucketModel `parquet:"name=grantee"`
	Permission string              `parquet:"name=permission,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type GranteeBucketModel struct {
	Type         string `parquet:"name=type,type=BYTE_ARRAY,convertedtype=UTF8"`
	DisplayName  string `parquet:"name=display_name,type=BYTE_ARRAY,convertedtype=UTF8"`
	EmailAddress string `parquet:"name=email_address,type=BYTE_ARRAY,convertedtype=UTF8"`
	ID           string `parquet:"name=id,type=BYTE_ARRAY,convertedtype=UTF8"`
	URI          string `parquet:"name=uri,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type CORSRuleBucketModel struct {
	AllowedMethods []string `parquet:"name=allowed_methods,type=MAP,convertedtype=LIST,valuetype=BYTE_ARRAY,valueconvertedtype=UTF8"`
	AllowedOrigins []string `parquet:"name=allowed_origins,type=MAP,convertedtype=LIST,valuetype=BYTE_ARRAY,valueconvertedtype=UTF8"`
	AllowedHeaders []string `parquet:"name=allowed_headers,type=MAP,convertedtype=LIST,valuetype=BYTE_ARRAY,valueconvertedtype=UTF8"`
	ExposeHeaders  []string `parquet:"name=expose_headers,type=MAP,convertedtype=LIST,valuetype=BYTE_ARRAY,valueconvertedtype=UTF8"`
	ID             string   `parquet:"name=id,type=BYTE_ARRAY,convertedtype=UTF8"`
	MaxAgeSeconds  int32    `parquet:"name=max_age_seconds,type=INT32"`
}

type ServerSideEncryptionConfigurationBucketModel struct {
	Rules []*ServerSideEncryptionRuleBucketModel `parquet:"name=rules,type=LIST"`
}

type ServerSideEncryptionRuleBucketModel struct {
	ApplyServerSideEncryptionByDefault *ServerSideEncryptionByDefaultBucketModel `parquet:"name=apply_server_side_encryption_by_default"`
	BucketKeyEnabled                   bool                                      `parquet:"name=bucket_key_enabled,type=BOOLEAN"`
}

type ServerSideEncryptionByDefaultBucketModel struct {
	SSEAlgorithm   string `parquet:"name=sse_algorithm,type=BYTE_ARRAY,convertedtype=UTF8"`
	KMSMasterKeyID string `parquet:"name=kms_master_key_id,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type IntelligentTieringConfigurationBucketModel struct {
	Id       string                               `parquet:"name=id,type=BYTE_ARRAY,convertedtype=UTF8"`
	Status   string                               `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
	Tierings []*TieringBucketModel                `parquet:"name=tierings,type=LIST"`
	Filter   *IntelligentTieringFilterBucketModel `parquet:"name=filter"`
}

type TieringBucketModel struct {
	AccessTier string `parquet:"name=access_tier,type=BYTE_ARRAY,convertedtype=UTF8"`
	Days       int32  `parquet:"name=days,type=INT32"`
}

type IntelligentTieringFilterBucketModel struct {
	And    *IntelligentTieringAndOperatorBucketModel `parquet:"name=and"`
	Prefix string                                    `parquet:"name=prefix,type=BYTE_ARRAY,convertedtype=UTF8"`
	Tag    *TagBucketModel                           `parquet:"name=tag"`
}

type IntelligentTieringAndOperatorBucketModel struct {
	Prefix string            `parquet:"name=prefix,type=BYTE_ARRAY,convertedtype=UTF8"`
	Tags   map[string]string `parquet:"name=tags,type=MAP,keytype=BYTE_ARRAY,valuetype=BYTE_ARRAY,keyconvertedtype=UTF8,valueconvertedtype=UTF8"`
}

type TagBucketModel struct {
	Key   string `parquet:"name=key,type=BYTE_ARRAY,convertedtype=UTF8"`
	Value string `parquet:"name=value,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type InventoryConfigurationBucketModel struct {
	Destination            *InventoryDestinationBucketModel `parquet:"name=destination"`
	Id                     string                           `parquet:"name=id,type=BYTE_ARRAY,convertedtype=UTF8"`
	IncludedObjectVersions string                           `parquet:"name=included_object_versions,type=BYTE_ARRAY,convertedtype=UTF8"`
	IsEnabled              bool                             `parquet:"name=is_enabled,type=BOOLEAN"`
	Schedule               *InventoryScheduleBucketModel    `parquet:"name=schedule"`
	Filter                 *InventoryFilterBucketModel      `parquet:"name=filter"`
	OptionalFields         []string                         `parquet:"name=optional_fields,type=MAP,convertedtype=LIST,valuetype=BYTE_ARRAY,valueconvertedtype=UTF8"`
}

type InventoryDestinationBucketModel struct {
	S3BucketDestination *InventoryS3BucketDestinationBucketModel `parquet:"name=s3_bucket_destination"`
}

type InventoryS3BucketDestinationBucketModel struct {
	Bucket     string                          `parquet:"name=bucket,type=BYTE_ARRAY,convertedtype=UTF8"`
	Format     string                          `parquet:"name=format,type=BYTE_ARRAY,convertedtype=UTF8"`
	AccountId  string                          `parquet:"name=account_id,type=BYTE_ARRAY,convertedtype=UTF8"`
	Encryption *InventoryEncryptionBucketModel `parquet:"name=encryption"`
	Prefix     string                          `parquet:"name=prefix,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type InventoryEncryptionBucketModel struct {
	SSEKMS *SSEKMSBucketModel `parquet:"name=ssekms"`
}

type SSEKMSBucketModel struct {
	KeyId string `parquet:"name=key_id,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type SSES3BucketModel struct {
}

type InventoryScheduleBucketModel struct {
	Frequency string `parquet:"name=frequency,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type InventoryFilterBucketModel struct {
	Prefix string `parquet:"name=prefix,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type LifecycleRuleBucketModel struct {
	Status                         string                                     `parquet:"name=status,type=BYTE_ARRAY,convertedtype=UTF8"`
	AbortIncompleteMultipartUpload *AbortIncompleteMultipartUploadBucketModel `parquet:"name=abort_incomplete_multipart_upload"`
	Expiration                     *LifecycleExpirationBucketModel            `parquet:"name=expiration"`
	ID                             string                                     `parquet:"name=id,type=BYTE_ARRAY,convertedtype=UTF8"`
	NoncurrentVersionExpiration    *NoncurrentVersionExpirationBucketModel    `parquet:"name=noncurrent_version_expiration"`
	NoncurrentVersionTransitions   []*NoncurrentVersionTransitionBucketModel  `parquet:"name=noncurrent_version_transitions,type=LIST"`
	Prefix                         string                                     `parquet:"name=prefix,type=BYTE_ARRAY,convertedtype=UTF8"`
	Transitions                    []*TransitionBucketModel                   `parquet:"name=transitions,type=LIST"`
}

type AbortIncompleteMultipartUploadBucketModel struct {
	DaysAfterInitiation int32 `parquet:"name=days_after_initiation,type=INT32"`
}

type LifecycleExpirationBucketModel struct {
	Date                      *time.Time
	DateMilli                 int64 `parquet:"name=date, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	Days                      int32 `parquet:"name=days,type=INT32"`
	ExpiredObjectDeleteMarker bool  `parquet:"name=expired_object_delete_marker,type=BOOLEAN"`
}

type NoncurrentVersionExpirationBucketModel struct {
	NoncurrentDays int32 `parquet:"name=noncurrent_days,type=INT32"`
}

type NoncurrentVersionTransitionBucketModel struct {
	NoncurrentDays int32  `parquet:"name=noncurrent_days,type=INT32"`
	StorageClass   string `parquet:"name=storage_class,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type TransitionBucketModel struct {
	Date         *time.Time
	DateMilli    int64  `parquet:"name=date, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	Days         int32  `parquet:"name=days,type=INT32"`
	StorageClass string `parquet:"name=storage_class,type=BYTE_ARRAY,convertedtype=UTF8"`
}

type LoggingEnabledBucketModel struct {
	TargetBucket string                    `parquet:"name=target_bucket,type=BYTE_ARRAY,convertedtype=UTF8"`
	TargetPrefix string                    `parquet:"name=target_prefix,type=BYTE_ARRAY,convertedtype=UTF8"`
	TargetGrants []*TargetGrantBucketModel `parquet:"name=target_grants,type=LIST"`
}

type TargetGrantBucketModel struct {
	Grantee    *GranteeBucketModel `parquet:"name=grantee"`
	Permission string              `parquet:"name=permission,type=BYTE_ARRAY,convertedtype=UTF8"`
}

func BucketDataSource(ctx context.Context, client *s3.Client, cfg aws.Config, reportTime time.Time, storageConfig storage.StorageContextConfig, storageManager *storage.StorageManager) error {
	storageContextSet, err := storageManager.GetStorageContextSet(storageConfig, new(BucketModel))
	if err != nil {
		return err
	}
	defer storageContextSet.Close(ctx)

	params := &s3.ListBucketsInput{}

	result, err := client.ListBuckets(ctx, params)
	if err != nil {
		logrus.WithFields(logrus.Fields{
			"service":     storageConfig.Service,
			"data_source": storageConfig.DataSource,
			"account_id":  storageConfig.AccountId,
			"region":      storageConfig.Region,
			"cloud":       storageConfig.Cloud,
			"error":       err,
		}).Error("error calling ListBuckets")
		return err
	}

	results := []*s3.ListBucketsOutput{result}
	for _, output := range results {

		for _, var0 := range output.Buckets {

			model := new(BucketModel)
			copier.Copy(&model, &var0)

			model.AccountId = storageConfig.AccountId
			model.Region = storageConfig.Region
			model.ReportTime = reportTime.UTC().UnixMilli()

			for _, f := range customBucketModelPostprocessingFuncs {
				f(ctx, client, cfg, model)
			}

			errors := storageContextSet.Store(ctx, model)
			for storageContext, err := range errors {
				storage.LogContextError(storageContext, fmt.Sprintf("Error storing BucketModel: %v", err))
			}
		}

	}

	return nil
}
